#version 430 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 2) uniform image2D gtaoTexture;

#define PI 3.1415926535897932384626433832795
#define PI_HALF 1.5707963267948966192313216916398

uniform sampler2D gPosition;
uniform sampler2D gNormal;

uniform vec2 reciprocalOfScreenSize;
uniform vec2 screenSize;

uniform int sliceCount = 8;
uniform int sampleCount = 4;

float GTAOFastAcos(float x)
{
    float res = -0.156583 * abs(x) + PI_HALF;
    res *= sqrt(1.0 - abs(x));
    return x >= 0 ? res : PI - res;
}

float integrateArc(float horizon1, float horizon2, float n) {
    float cosN = cos(n), sinN = sin(n);

    float h1Integral = 0.25 * (-cos(2 * horizon1 - n) + cosN + 2 * horizon1 * sinN);
    float h2Integral = 0.25 * (-cos(2 * horizon2 - n) + cosN + 2 * horizon2 * sinN);
    return h1Integral + h2Integral;
}

void main() {
    // Use texCoords and get sample data
    ivec2 texCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 convertedTexCoords = vec2(texCoords.x / 1920.0, texCoords.y / 1080.0);

    float initialMipLevel = clamp(log2(length(convertedTexCoords)) - 3.3, 0.0, 5.0);

    vec3 normal = textureLod(gNormal, convertedTexCoords, initialMipLevel).xyz;
    vec3 viewSpacePos = textureLod(gPosition, convertedTexCoords, initialMipLevel).xyz;
    vec3 viewVector = normalize(-viewSpacePos);

    // Initialize extra variables
    float effectRadius = 0.5 * 1.457;
    float falloffRange = 0.615 * effectRadius;
    float falloffFrom = effectRadius * (1.0 - 0.615);
    float falloffMultipler = -1.0 / falloffRange;
    float falloffAdd = falloffFrom / falloffRange + 1.0;

    float visibility = 0.0;
    for (int slice = 0; slice < sliceCount; slice++) {
        float angle = (PI / sliceCount) * slice;
        vec2 angleVector = vec2(cos(angle), sin(angle));

        vec3 directionVector = vec3(angleVector.x, angleVector.y, 0);
        vec3 orthoDirectionVector = directionVector - (dot(directionVector, viewVector) * viewVector);
        vec3 axis = cross(directionVector, viewVector);
        vec3 projectedNormal = normal - axis * dot(normal, axis);

        float signOfNormal = sign(dot(orthoDirectionVector, projectedNormal));
        float cosNormal = dot(projectedNormal, viewVector) / length(projectedNormal);
        float clampedCos = clamp(cosNormal, 0.0, 1.0);

        float n = signOfNormal * GTAOFastAcos(clampedCos);

        for (int side = 0; side <= 1; side++) {
            float horizonCos = -1.0;
            int sideValue = side * 2 - 1;
            float minHorizonCos = cos(n + sideValue * PI_HALF);
            vec2 sampleMultipler = vec2(angleVector.x, angleVector.y) * reciprocalOfScreenSize;

            for (float currentSample = 0; currentSample < sampleCount; currentSample += 1.0) {
                float s = currentSample / sampleCount;

                vec2 sTexCoords = convertedTexCoords + sideValue * s * sampleMultipler;
                float sampleMipLevel = clamp(log2(length(sTexCoords)) - 3.3, 0.0, 5.0);

                vec3 otherPos = textureLod(gPosition, sTexCoords, sampleMipLevel).xyz;
                vec3 horizonVec = normalize(otherPos - viewSpacePos);
                float sampleHorizonCos = dot(horizonVec, viewVector);

                float weight = clamp(sampleHorizonCos * falloffMultipler + falloffAdd, 0.0, 1.0);

                float newSampleHorizonCos = mix(minHorizonCos, sampleHorizonCos, weight);

                horizonCos = max(horizonCos, newSampleHorizonCos);
            }

            float horizonValue = n + clamp(sideValue * GTAOFastAcos(horizonCos) - n, -PI_HALF, PI_HALF);
            float horizonIntegral = 0.25 * (clampedCos + 2.0 * horizonValue * sin(n) - cos(2.0 * horizonValue - n));
            visibility += length(projectedNormal) * horizonIntegral;
        }
    }
    visibility /= sliceCount;

    imageStore(gtaoTexture, texCoords, vec4(visibility / 20.0, 0.0, 0.0, 1.0));
}